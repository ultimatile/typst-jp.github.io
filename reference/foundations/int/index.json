{"route":"/docs/reference/foundations/int/","title":"Integer","description":"Documentation for the Integer type.","part":null,"outline":[{"id":"summary","name":"概要","children":[]},{"id":"example","name":"Example","children":[]},{"id":"constructor","name":"コンストラクタ","children":[{"id":"constructor-value","name":"value","children":[]}]},{"id":"definitions","name":"定義","children":[{"id":"definitions-signum","name":"Signum","children":[]},{"id":"definitions-bit-not","name":"Bitwise NOT","children":[]},{"id":"definitions-bit-and","name":"Bitwise AND","children":[{"id":"definitions-bit-and-rhs","name":"rhs","children":[]}]},{"id":"definitions-bit-or","name":"Bitwise OR","children":[{"id":"definitions-bit-or-rhs","name":"rhs","children":[]}]},{"id":"definitions-bit-xor","name":"Bitwise XOR","children":[{"id":"definitions-bit-xor-rhs","name":"rhs","children":[]}]},{"id":"definitions-bit-lshift","name":"Bitwise Left Shift","children":[{"id":"definitions-bit-lshift-shift","name":"shift","children":[]}]},{"id":"definitions-bit-rshift","name":"Bitwise Right Shift","children":[{"id":"definitions-bit-rshift-shift","name":"shift","children":[]},{"id":"definitions-bit-rshift-logical","name":"logical","children":[]}]},{"id":"definitions-from-bytes","name":"From Bytes","children":[{"id":"definitions-from-bytes-bytes","name":"bytes","children":[]},{"id":"definitions-from-bytes-endian","name":"endian","children":[]},{"id":"definitions-from-bytes-signed","name":"signed","children":[]}]},{"id":"definitions-to-bytes","name":"To Bytes","children":[{"id":"definitions-to-bytes-endian","name":"endian","children":[]},{"id":"definitions-to-bytes-size","name":"size","children":[]}]}]}],"body":{"kind":"type","content":{"name":"int","title":"Integer","keywords":[],"oneliner":"A whole number.","details":"<p>A whole number.</p>\n<p>The number can be negative, zero, or positive. As Typst uses 64 bits to\nstore integers, integers cannot be smaller than <code><span class=\"typ-op\">-</span><span class=\"typ-num\">9223372036854775808</span></code> or\nlarger than <code><span class=\"typ-num\">9223372036854775807</span></code>. Integer literals are always positive,\nso a negative integer such as <code><span class=\"typ-op\">-</span><span class=\"typ-num\">1</span></code> is semantically the negation <code>-</code> of the\npositive literal <code>1</code>. A positive integer greater than the maximum value and\na negative integer less than or equal to the minimum value cannot be\nrepresented as an integer literal, and are instead parsed as a <code>float</code>.\nThe minimum integer value can still be obtained through integer arithmetic.</p>\n<p>The number can also be specified as hexadecimal, octal, or binary by\nstarting it with a zero followed by either <code>x</code>, <code>o</code>, or <code>b</code>.</p>\n<p>You can convert a value to an integer with this type's constructor.</p>\n<h2 id=\"example\">Example</h2>\n<div class=\"previewed-code\"><pre><code><span class=\"typ-punct\">#</span><span class=\"typ-punct\">(</span><span class=\"typ-num\">1</span> <span class=\"typ-op\">+</span> <span class=\"typ-num\">2</span><span class=\"typ-punct\">)</span> <span class=\"typ-escape\">\\</span>\n<span class=\"typ-punct\">#</span><span class=\"typ-punct\">(</span><span class=\"typ-num\">2</span> <span class=\"typ-op\">-</span> <span class=\"typ-num\">5</span><span class=\"typ-punct\">)</span> <span class=\"typ-escape\">\\</span>\n<span class=\"typ-punct\">#</span><span class=\"typ-punct\">(</span><span class=\"typ-num\">3</span> <span class=\"typ-op\">+</span> <span class=\"typ-num\">4</span> <span class=\"typ-op\">&lt;</span> <span class=\"typ-num\">8</span><span class=\"typ-punct\">)</span>\n\n<span class=\"typ-num\">#</span><span class=\"typ-num\">0xff</span> <span class=\"typ-escape\">\\</span>\n<span class=\"typ-num\">#</span><span class=\"typ-num\">0o10</span> <span class=\"typ-escape\">\\</span>\n<span class=\"typ-num\">#</span><span class=\"typ-num\">0b1001</span>\n</code></pre><div class=\"preview\"><img src=\"/docs/assets/c1fa714490d9acd7860c0dd18c480526.png\" alt=\"Preview\"></div></div>","constructor":{"path":[],"name":"int","title":"Construct","keywords":[],"oneliner":"Converts a value to an integer. Raises an error if there is an attempt","element":false,"contextual":false,"deprecation":null,"details":"<p>Converts a value to an integer. Raises an error if there is an attempt\nto produce an integer larger than the maximum 64-bit signed integer\nor smaller than the minimum 64-bit signed integer.</p>\n<ul>\n<li>Booleans are converted to <code>0</code> or <code>1</code>.</li>\n<li>Floats and decimals are truncated to the next 64-bit integer.</li>\n<li>Strings are parsed in base 10.</li>\n</ul>","example":"<div class=\"previewed-code\"><pre><code><span class=\"typ-func\">#</span><span class=\"typ-func\">int</span><span class=\"typ-punct\">(</span><span class=\"typ-key\">false</span><span class=\"typ-punct\">)</span> <span class=\"typ-escape\">\\</span>\n<span class=\"typ-func\">#</span><span class=\"typ-func\">int</span><span class=\"typ-punct\">(</span><span class=\"typ-key\">true</span><span class=\"typ-punct\">)</span> <span class=\"typ-escape\">\\</span>\n<span class=\"typ-func\">#</span><span class=\"typ-func\">int</span><span class=\"typ-punct\">(</span><span class=\"typ-num\">2.7</span><span class=\"typ-punct\">)</span> <span class=\"typ-escape\">\\</span>\n<span class=\"typ-func\">#</span><span class=\"typ-func\">int</span><span class=\"typ-punct\">(</span><span class=\"typ-func\">decimal</span><span class=\"typ-punct\">(</span><span class=\"typ-str\">&quot;3.8&quot;</span><span class=\"typ-punct\">)</span><span class=\"typ-punct\">)</span> <span class=\"typ-escape\">\\</span>\n<span class=\"typ-punct\">#</span><span class=\"typ-punct\">(</span><span class=\"typ-func\">int</span><span class=\"typ-punct\">(</span><span class=\"typ-str\">&quot;27&quot;</span><span class=\"typ-punct\">)</span> <span class=\"typ-op\">+</span> <span class=\"typ-func\">int</span><span class=\"typ-punct\">(</span><span class=\"typ-str\">&quot;4&quot;</span><span class=\"typ-punct\">)</span><span class=\"typ-punct\">)</span>\n</code></pre><div class=\"preview\"><img src=\"/docs/assets/e2f0ccff01ef1801aace21ddf72d8b41.png\" alt=\"Preview\"></div></div>","self":false,"params":[{"name":"value","details":"<p>The value that should be converted to an integer.</p>","example":null,"types":["bool","int","float","str","decimal"],"strings":[],"default":null,"positional":true,"named":false,"required":true,"variadic":false,"settable":false}],"returns":["int"],"scope":[]},"scope":[{"path":["int"],"name":"signum","title":"Signum","keywords":[],"oneliner":"Calculates the sign of an integer.","element":false,"contextual":false,"deprecation":null,"details":"<p>Calculates the sign of an integer.</p>\n<ul>\n<li>If the number is positive, returns <code><span class=\"typ-num\">1</span></code>.</li>\n<li>If the number is negative, returns <code><span class=\"typ-op\">-</span><span class=\"typ-num\">1</span></code>.</li>\n<li>If the number is zero, returns <code><span class=\"typ-num\">0</span></code>.</li>\n</ul>","example":"<div class=\"previewed-code\"><pre><code><span class=\"typ-punct\">#</span><span class=\"typ-punct\">(</span><span class=\"typ-num\">5</span><span class=\"typ-punct\">)</span><span class=\"typ-punct\">.</span><span class=\"typ-func\">signum</span><span class=\"typ-punct\">(</span><span class=\"typ-punct\">)</span> <span class=\"typ-escape\">\\</span>\n<span class=\"typ-punct\">#</span><span class=\"typ-punct\">(</span><span class=\"typ-op\">-</span><span class=\"typ-num\">5</span><span class=\"typ-punct\">)</span><span class=\"typ-punct\">.</span><span class=\"typ-func\">signum</span><span class=\"typ-punct\">(</span><span class=\"typ-punct\">)</span> <span class=\"typ-escape\">\\</span>\n<span class=\"typ-punct\">#</span><span class=\"typ-punct\">(</span><span class=\"typ-num\">0</span><span class=\"typ-punct\">)</span><span class=\"typ-punct\">.</span><span class=\"typ-func\">signum</span><span class=\"typ-punct\">(</span><span class=\"typ-punct\">)</span>\n</code></pre><div class=\"preview\"><img src=\"/docs/assets/562726d9517a67df2c82335941895a06.png\" alt=\"Preview\"></div></div>","self":true,"params":[],"returns":["int"],"scope":[]},{"path":["int"],"name":"bit-not","title":"Bitwise NOT","keywords":[],"oneliner":"Calculates the bitwise NOT of an integer.","element":false,"contextual":false,"deprecation":null,"details":"<p>Calculates the bitwise NOT of an integer.</p>\n<p>For the purposes of this function, the operand is treated as a signed\ninteger of 64 bits.</p>","example":"<div class=\"previewed-code\"><pre><code><span class=\"typ-num\">#</span><span class=\"typ-num\">4</span><span class=\"typ-punct\">.</span><span class=\"typ-func\">bit-not</span><span class=\"typ-punct\">(</span><span class=\"typ-punct\">)</span> <span class=\"typ-escape\">\\</span>\n<span class=\"typ-punct\">#</span><span class=\"typ-punct\">(</span><span class=\"typ-op\">-</span><span class=\"typ-num\">1</span><span class=\"typ-punct\">)</span><span class=\"typ-punct\">.</span><span class=\"typ-func\">bit-not</span><span class=\"typ-punct\">(</span><span class=\"typ-punct\">)</span>\n</code></pre><div class=\"preview\"><img src=\"/docs/assets/dc060efa9e84fb3dd52c7e2f3725842a.png\" alt=\"Preview\"></div></div>","self":true,"params":[],"returns":["int"],"scope":[]},{"path":["int"],"name":"bit-and","title":"Bitwise AND","keywords":[],"oneliner":"Calculates the bitwise AND between two integers.","element":false,"contextual":false,"deprecation":null,"details":"<p>Calculates the bitwise AND between two integers.</p>\n<p>For the purposes of this function, the operands are treated as signed\nintegers of 64 bits.</p>","example":"<div class=\"previewed-code\"><pre><code><span class=\"typ-num\">#</span><span class=\"typ-num\">128</span><span class=\"typ-punct\">.</span><span class=\"typ-func\">bit-and</span><span class=\"typ-punct\">(</span><span class=\"typ-num\">192</span><span class=\"typ-punct\">)</span>\n</code></pre><div class=\"preview\"><img src=\"/docs/assets/927c13ad6f976e3e6ca9b71dcdaedec2.png\" alt=\"Preview\"></div></div>","self":true,"params":[{"name":"rhs","details":"<p>The right-hand operand of the bitwise AND.</p>","example":null,"types":["int"],"strings":[],"default":null,"positional":true,"named":false,"required":true,"variadic":false,"settable":false}],"returns":["int"],"scope":[]},{"path":["int"],"name":"bit-or","title":"Bitwise OR","keywords":[],"oneliner":"Calculates the bitwise OR between two integers.","element":false,"contextual":false,"deprecation":null,"details":"<p>Calculates the bitwise OR between two integers.</p>\n<p>For the purposes of this function, the operands are treated as signed\nintegers of 64 bits.</p>","example":"<div class=\"previewed-code\"><pre><code><span class=\"typ-num\">#</span><span class=\"typ-num\">64</span><span class=\"typ-punct\">.</span><span class=\"typ-func\">bit-or</span><span class=\"typ-punct\">(</span><span class=\"typ-num\">32</span><span class=\"typ-punct\">)</span>\n</code></pre><div class=\"preview\"><img src=\"/docs/assets/cda54a333b5f8fef1521f6cb5de24550.png\" alt=\"Preview\"></div></div>","self":true,"params":[{"name":"rhs","details":"<p>The right-hand operand of the bitwise OR.</p>","example":null,"types":["int"],"strings":[],"default":null,"positional":true,"named":false,"required":true,"variadic":false,"settable":false}],"returns":["int"],"scope":[]},{"path":["int"],"name":"bit-xor","title":"Bitwise XOR","keywords":[],"oneliner":"Calculates the bitwise XOR between two integers.","element":false,"contextual":false,"deprecation":null,"details":"<p>Calculates the bitwise XOR between two integers.</p>\n<p>For the purposes of this function, the operands are treated as signed\nintegers of 64 bits.</p>","example":"<div class=\"previewed-code\"><pre><code><span class=\"typ-num\">#</span><span class=\"typ-num\">64</span><span class=\"typ-punct\">.</span><span class=\"typ-func\">bit-xor</span><span class=\"typ-punct\">(</span><span class=\"typ-num\">96</span><span class=\"typ-punct\">)</span>\n</code></pre><div class=\"preview\"><img src=\"/docs/assets/2943eab0e2f921759c1927c0845a4beb.png\" alt=\"Preview\"></div></div>","self":true,"params":[{"name":"rhs","details":"<p>The right-hand operand of the bitwise XOR.</p>","example":null,"types":["int"],"strings":[],"default":null,"positional":true,"named":false,"required":true,"variadic":false,"settable":false}],"returns":["int"],"scope":[]},{"path":["int"],"name":"bit-lshift","title":"Bitwise Left Shift","keywords":[],"oneliner":"Shifts the operand's bits to the left by the specified amount.","element":false,"contextual":false,"deprecation":null,"details":"<p>Shifts the operand's bits to the left by the specified amount.</p>\n<p>For the purposes of this function, the operand is treated as a signed\ninteger of 64 bits. An error will occur if the result is too large to\nfit in a 64-bit integer.</p>","example":"<div class=\"previewed-code\"><pre><code><span class=\"typ-num\">#</span><span class=\"typ-num\">33</span><span class=\"typ-punct\">.</span><span class=\"typ-func\">bit-lshift</span><span class=\"typ-punct\">(</span><span class=\"typ-num\">2</span><span class=\"typ-punct\">)</span> <span class=\"typ-escape\">\\</span>\n<span class=\"typ-punct\">#</span><span class=\"typ-punct\">(</span><span class=\"typ-op\">-</span><span class=\"typ-num\">1</span><span class=\"typ-punct\">)</span><span class=\"typ-punct\">.</span><span class=\"typ-func\">bit-lshift</span><span class=\"typ-punct\">(</span><span class=\"typ-num\">3</span><span class=\"typ-punct\">)</span>\n</code></pre><div class=\"preview\"><img src=\"/docs/assets/9085484b226c6c6a4ade4fdfbb9f4ed8.png\" alt=\"Preview\"></div></div>","self":true,"params":[{"name":"shift","details":"<p>The amount of bits to shift. Must not be negative.</p>","example":null,"types":["int"],"strings":[],"default":null,"positional":true,"named":false,"required":true,"variadic":false,"settable":false}],"returns":["int"],"scope":[]},{"path":["int"],"name":"bit-rshift","title":"Bitwise Right Shift","keywords":[],"oneliner":"Shifts the operand's bits to the right by the specified amount.","element":false,"contextual":false,"deprecation":null,"details":"<p>Shifts the operand's bits to the right by the specified amount.\nPerforms an arithmetic shift by default (extends the sign bit to the left,\nsuch that negative numbers stay negative), but that can be changed by the\n<code>logical</code> parameter.</p>\n<p>For the purposes of this function, the operand is treated as a signed\ninteger of 64 bits.</p>","example":"<div class=\"previewed-code\"><pre><code><span class=\"typ-num\">#</span><span class=\"typ-num\">64</span><span class=\"typ-punct\">.</span><span class=\"typ-func\">bit-rshift</span><span class=\"typ-punct\">(</span><span class=\"typ-num\">2</span><span class=\"typ-punct\">)</span> <span class=\"typ-escape\">\\</span>\n<span class=\"typ-punct\">#</span><span class=\"typ-punct\">(</span><span class=\"typ-op\">-</span><span class=\"typ-num\">8</span><span class=\"typ-punct\">)</span><span class=\"typ-punct\">.</span><span class=\"typ-func\">bit-rshift</span><span class=\"typ-punct\">(</span><span class=\"typ-num\">2</span><span class=\"typ-punct\">)</span> <span class=\"typ-escape\">\\</span>\n<span class=\"typ-punct\">#</span><span class=\"typ-punct\">(</span><span class=\"typ-op\">-</span><span class=\"typ-num\">8</span><span class=\"typ-punct\">)</span><span class=\"typ-punct\">.</span><span class=\"typ-func\">bit-rshift</span><span class=\"typ-punct\">(</span><span class=\"typ-num\">2</span><span class=\"typ-punct\">,</span> logical<span class=\"typ-punct\">:</span> <span class=\"typ-key\">true</span><span class=\"typ-punct\">)</span>\n</code></pre><div class=\"preview\"><img src=\"/docs/assets/81e6da07e0993b30ed9ef7e30df8ed4e.png\" alt=\"Preview\"></div></div>","self":true,"params":[{"name":"shift","details":"<p>The amount of bits to shift. Must not be negative.</p>\n<p>Shifts larger than 63 are allowed and will cause the return value to\nsaturate. For non-negative numbers, the return value saturates at\n<code><span class=\"typ-num\">0</span></code>, while, for negative numbers, it saturates at <code><span class=\"typ-op\">-</span><span class=\"typ-num\">1</span></code> if\n<code>logical</code> is set to <code><span class=\"typ-key\">false</span></code>, or <code><span class=\"typ-num\">0</span></code> if it is <code><span class=\"typ-key\">true</span></code>. This\nbehavior is consistent with just applying this operation multiple\ntimes. Therefore, the shift will always succeed.</p>","example":null,"types":["int"],"strings":[],"default":null,"positional":true,"named":false,"required":true,"variadic":false,"settable":false},{"name":"logical","details":"<p>Toggles whether a logical (unsigned) right shift should be performed\ninstead of arithmetic right shift.\nIf this is <code><span class=\"typ-key\">true</span></code>, negative operands will not preserve their sign\nbit, and bits which appear to the left after the shift will be\n<code><span class=\"typ-num\">0</span></code>. This parameter has no effect on non-negative operands.</p>","example":null,"types":["bool"],"strings":[],"default":"<code><span class=\"typ-key\">false</span></code>","positional":false,"named":true,"required":false,"variadic":false,"settable":false}],"returns":["int"],"scope":[]},{"path":["int"],"name":"from-bytes","title":"From Bytes","keywords":[],"oneliner":"Converts bytes to an integer.","element":false,"contextual":false,"deprecation":null,"details":"<p>Converts bytes to an integer.</p>","example":"<div class=\"previewed-code\"><pre><code><span class=\"typ-pol\">#</span><span class=\"typ-pol\">int</span><span class=\"typ-punct\">.</span><span class=\"typ-func\">from-bytes</span><span class=\"typ-punct\">(</span><span class=\"typ-func\">bytes</span><span class=\"typ-punct\">(</span><span class=\"typ-punct\">(</span><span class=\"typ-num\">0</span><span class=\"typ-punct\">,</span> <span class=\"typ-num\">0</span><span class=\"typ-punct\">,</span> <span class=\"typ-num\">0</span><span class=\"typ-punct\">,</span> <span class=\"typ-num\">0</span><span class=\"typ-punct\">,</span> <span class=\"typ-num\">0</span><span class=\"typ-punct\">,</span> <span class=\"typ-num\">0</span><span class=\"typ-punct\">,</span> <span class=\"typ-num\">0</span><span class=\"typ-punct\">,</span> <span class=\"typ-num\">1</span><span class=\"typ-punct\">)</span><span class=\"typ-punct\">)</span><span class=\"typ-punct\">)</span> <span class=\"typ-escape\">\\</span>\n<span class=\"typ-pol\">#</span><span class=\"typ-pol\">int</span><span class=\"typ-punct\">.</span><span class=\"typ-func\">from-bytes</span><span class=\"typ-punct\">(</span><span class=\"typ-func\">bytes</span><span class=\"typ-punct\">(</span><span class=\"typ-punct\">(</span><span class=\"typ-num\">1</span><span class=\"typ-punct\">,</span> <span class=\"typ-num\">0</span><span class=\"typ-punct\">,</span> <span class=\"typ-num\">0</span><span class=\"typ-punct\">,</span> <span class=\"typ-num\">0</span><span class=\"typ-punct\">,</span> <span class=\"typ-num\">0</span><span class=\"typ-punct\">,</span> <span class=\"typ-num\">0</span><span class=\"typ-punct\">,</span> <span class=\"typ-num\">0</span><span class=\"typ-punct\">,</span> <span class=\"typ-num\">0</span><span class=\"typ-punct\">)</span><span class=\"typ-punct\">)</span><span class=\"typ-punct\">,</span> endian<span class=\"typ-punct\">:</span> <span class=\"typ-str\">&quot;big&quot;</span><span class=\"typ-punct\">)</span>\n</code></pre><div class=\"preview\"><img src=\"/docs/assets/2342cf4345948a2d1fb61703db4728b0.png\" alt=\"Preview\"></div></div>","self":false,"params":[{"name":"bytes","details":"<p>The bytes that should be converted to an integer.</p>\n<p>Must be of length at most 8 so that the result fits into a 64-bit\nsigned integer.</p>","example":null,"types":["bytes"],"strings":[],"default":null,"positional":true,"named":false,"required":true,"variadic":false,"settable":false},{"name":"endian","details":"<p>The endianness of the conversion.</p>","example":null,"types":["str"],"strings":[{"string":"big","details":"<p>Big-endian byte order: The highest-value byte is at the beginning of the\nbytes.</p>"},{"string":"little","details":"<p>Little-endian byte order: The lowest-value byte is at the beginning of\nthe bytes.</p>"}],"default":"<code><span class=\"typ-str\">&quot;little&quot;</span></code>","positional":false,"named":true,"required":false,"variadic":false,"settable":false},{"name":"signed","details":"<p>Whether the bytes should be treated as a signed integer. If this is\n<code><span class=\"typ-key\">true</span></code> and the most significant bit is set, the resulting number\nwill negative.</p>","example":null,"types":["bool"],"strings":[],"default":"<code><span class=\"typ-key\">true</span></code>","positional":false,"named":true,"required":false,"variadic":false,"settable":false}],"returns":["int"],"scope":[]},{"path":["int"],"name":"to-bytes","title":"To Bytes","keywords":[],"oneliner":"Converts an integer to bytes.","element":false,"contextual":false,"deprecation":null,"details":"<p>Converts an integer to bytes.</p>","example":"<div class=\"previewed-code\"><pre><code><span class=\"typ-func\">#</span><span class=\"typ-func\">array</span><span class=\"typ-punct\">(</span><span class=\"typ-num\">10000</span><span class=\"typ-punct\">.</span><span class=\"typ-func\">to-bytes</span><span class=\"typ-punct\">(</span>endian<span class=\"typ-punct\">:</span> <span class=\"typ-str\">&quot;big&quot;</span><span class=\"typ-punct\">)</span><span class=\"typ-punct\">)</span> <span class=\"typ-escape\">\\</span>\n<span class=\"typ-func\">#</span><span class=\"typ-func\">array</span><span class=\"typ-punct\">(</span><span class=\"typ-num\">10000</span><span class=\"typ-punct\">.</span><span class=\"typ-func\">to-bytes</span><span class=\"typ-punct\">(</span>size<span class=\"typ-punct\">:</span> <span class=\"typ-num\">4</span><span class=\"typ-punct\">)</span><span class=\"typ-punct\">)</span>\n</code></pre><div class=\"preview\"><img src=\"/docs/assets/145ee0196e1e54e1216232195f2f0122.png\" alt=\"Preview\"></div></div>","self":true,"params":[{"name":"endian","details":"<p>The endianness of the conversion.</p>","example":null,"types":["str"],"strings":[{"string":"big","details":"<p>Big-endian byte order: The highest-value byte is at the beginning of the\nbytes.</p>"},{"string":"little","details":"<p>Little-endian byte order: The lowest-value byte is at the beginning of\nthe bytes.</p>"}],"default":"<code><span class=\"typ-str\">&quot;little&quot;</span></code>","positional":false,"named":true,"required":false,"variadic":false,"settable":false},{"name":"size","details":"<p>The size in bytes of the resulting bytes (must be at least zero). If\nthe integer is too large to fit in the specified size, the\nconversion will truncate the remaining bytes based on the\nendianness. To keep the same resulting value, if the endianness is\nbig-endian, the truncation will happen at the rightmost bytes.\nOtherwise, if the endianness is little-endian, the truncation will\nhappen at the leftmost bytes.</p>\n<p>Be aware that if the integer is negative and the size is not enough\nto make the number fit, when passing the resulting bytes to\n<code>int.from-bytes</code>, the resulting number might be positive, as the\nmost significant bit might not be set to 1.</p>","example":null,"types":["int"],"strings":[],"default":"<code><span class=\"typ-num\">8</span></code>","positional":false,"named":true,"required":false,"variadic":false,"settable":false}],"returns":["bytes"],"scope":[]}]}}}